\section{Solución Propuesta}
\label{sec:solution}

Es por ende de amplio interés para los desarrolladores contar con una 
herramienta que corra sobre la \jvm y que permita manejar las \dependencies de 
la \viewtier.\\
El presente trabajo propone entonces el desarrollo de un \depmgr hecho en 
\scala. El mismo utilizará \conffiles con distintos formatos para configurar 
las dependencias requeridos. Adicionalmente, se integrará con herramientas 
externas para facilitar su uso con los flujos de trabajo ya establecidos.\\

\subsection{Características deseadas}
\label{subsec:solution:whishlist}

En primer lugar, hay que tener en cuenta que lo que se desea es generar una 
herramienta que se posicione como el estándar de los lenguajes de la \jvm en 
cuanto a lo que manejo de \dependencies de la \viewtier se refiere. Las 
siguientes son todas aquellas características deseables en la herramienta a 
desarrollar.

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item Hecho enteramente sobre la \jvm
	\item Posibilidad de ser usado desde cualquier lenguaje de 
	la \jvm
	\item Archivos de configuración personalizados, con varios 
	formatos por defecto
	\item Múltiples repositorios
	\item Seguridad mediante autenticación en los repositorios
	\item Integración con estándares existentes de \depmgrs
	\item Integración con tecnologías web existentes en la \jvm
\end{itemize}

En primer lugar deberá correr enteramente sobre la \jvm, evitando depender de 
la instalación de software adicional en el equipo y haciendolo independiente 
del sistema operativo. Por esto, es necesario que se encuentre desarrollada 
integramente en uno varios lenguajes que compilen a \bytecode \java.  
Adicionalmente deberá poder ser utilizada desde cualquier otro lenguaje de la 
\jvm de forma natural. En caso de características incompatibles de los 
lenguajes, debería proveer una capa de abstracción de forma tal que el uso sea 
transparente y completo. Incluso es deseable que pueda ser ejecutada en forma 
de programa independiente desde la linea de comandos. Esto último posibilitaría 
que pueda ser utilizado prácticamente desde cualquier lenguaje, aunque implica 
contar con acceso al sistema de archivos del sistema operativo.\\
La herramienta deberá ser capaz de descargar y acomodar los paquetes que el 
usuario determine como \dependencies en un \conffile. En lugar de forzar un 
formato especifico para el \conffile, el \depmgr desarrollado deberá brindar al 
usuario la posibilidad de usar un formato que se adecue a sus 
necesidades\footnote{
	Por ejemplo, los usuarios de \apache \maven podrían optar por un archivo de 
	configuración en \xml similar al que acostumbran y conocen, mientras que 
	los usuarios de \sbt podrían elegir un archivo de configuración cuya 
	sintaxis asemeje los usados en esa herramienta. Debería ser lo bastante 
	flexible para permitir la generación de formatos de archivo de 
	configuración por los mismos usuarios de la herramienta de forma sencilla.
}.\\
Al existir soluciones como \emph{Bower} o \emph{Component} la herramienta 
debería complementarlas, permitiendo por ejemplo utilizar sus archivos de 
configuración y sus repositorios.\\
Finalmente, sería ideal contar con un repositorio central, en donde 
desarrolladores puedan subir sus paquetes, o al menos registrar los mismos, 
permitiendo así consultar la existencia de dependencias. Además, los usuarios 
podrían querer generar sus propios repositorios y hacer que la herramienta 
consulte en ellos, evitando la centralización del repositorio. Esta dualidad 
entre contar con un repositorio centralizado, y múltiples repositorios 
descentralizados, permite a organizaciones de distinto tamaño contar con 
posibilidades acorde a sus requerimientos, y se ha mostrado exitosa en 
proyectos como \maven.\\
Algunos de estos repositorios podrían ser privados, y por tanto, se requeriría 
acceso mediante un usuario y contraseña que la herramienta debe enviar de forma 
correcta y segura.\\
Finalmente, al existir numerosos \frameworks para distintos lenguajes de la 
\jvm que apuntan al desarrollo de aplicaciones web, sería deseable la 
integración con los mismos\footnote{
	Por ejemplo, múltiples \frameworks utilizan sistemas de templates para 
	generar el código \html que finalmente será utilizado. Sería ideal poder 
	brindar algún componente que integre los elementos descargados a los 
	templates del usuario de forma automática.
}.\\
Podemos agregar además que la mayoría de los \depmgrs actuales se basan en 
archivos, es decir, un archivo por dependencia. En las \dependencies de la 
\viewtier esto no es necesariamente cierto, y a veces una dependencia consiste 
en múltiples archivos. La herramienta tiene que proveer una forma de 
contemplar estos casos para permitir bajar todos los archivos que sean 
necesarios.\\
Otros requerimientos podrían surgir a futuro, pero no son tenidos en cuenta al 
momento de desarrollar esta solución.


\subsection{Elección de tecnologías a utilizar}
\label{subsec:solution:technology}

Se utilizará \scala para desarrollar la aplicación. La elección se basa en que 
la combinación de \emph{Programación Orientada a Objetos} y \emph{Programación 
	Funcional} que presenta el lenguaje permiten desarrollar complejas soluciones 
en poco tiempo. Además, el código desarrollado es de fácil mantenimiento 
y gran expresibilidad, dado a la capacidad de \scala de crear sencillos DSLs.\\
Adicionalmente, este lenguaje presenta una gran cantidad de bibliotecas 
estándar que permiten realizar rapidamente tareas complejas. Por ejemplo, su 
biblioteca de análisis sintáctico (\emph{parsing}) resultarán muy útiles cuando 
se requiera leer archivos de configuración.\\
\scala será utilizado en combinación con \sbt para manejar las dependencias del 
proyecto.\\
Al momento de desarrollar herramientas de integración con otros lenguajes o 
tecnologías existentes es posible que sea necesario el uso de otros lenguajes, 
como \java, \clojure o \groovy.


\subsection{Alcance del presente trabajo}
\label{subsec:solution:todo}

El alcance del presente trabajo no abarca la totalidad de las caracteristicas 
deseadas expresadas en \ref{subsec:solution:whishlist}. El mismo solamente se 
enfocará en las funcionalidades más importantes y  dejará asentadas las bases 
para el desarrollo de las partes no desarrolladas en trabajos futuros. Así, el 
enfoque será puesto en la estructura del sistema, orientada siempre a la 
extensibilidad del mismo.\\
Se presenta como objetivo el desarrollo de al menos las siguientes 
funcionalidades:
\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item Desarrollo del núcleo del sistema
	\item Descargar dependencias desde la web vía \http
	\item Descargar desde \gls{github} mediante \git
	\item Descargar desde un repositorio \svn
	\item Lectura de \conffiles en \xml estilo \apache \maven
	\item Lectura de \conffiles en \xml estilo \apache \ivy
	\item Lectura de \conffiles en estilo \sbt
	\item Agregado de múltiples repositorios
	\item Usar la herramienta desde la linea de comandos
	\item Usar la herramienta desde \scala
	\item Usar la herramienta desde \java
	\item Integración de la herramienta con \apache \maven
	\item Integración de la herramienta con \sbt
	\item Integración de la herramienta con Play! Framework
\end{itemize}

La herramienta será liberada como \freesoft con licencia \apache versión 2. 
Esto permitirá que la comunidad de desarrolladores expanda la herramienta para  
funcionar con todos los lenguajes de la \jvm, en muchos más \frameworks, y que  
se integre con una mayor cantidad de procesos.\\
Para lograr una buena recepción por parte de la comunidad de \freesoft, la 
documentación del proyecto es sumamente importante. El desarrollo debe contar 
necesariamente con documentación que apunte a explicar la estructura del 
sistema, así como el código utilizado. También resulta interesante contar con 
un centro de referencia para futuros desarrolladores, por lo que colocar esta 
documentación a disposición de la comunidad a través de \internet es esencial.

\subsection{Elección del nombre}
\label{subsec:solution:naming}

La herramienta recibirá el nombre de \fronttier. El nombre deviene de un juego 
de palabras entre las palabras \emph{front} (nombre que se le suele dar a la 
\viewtier) y \emph{tier} (El nombre que recibe cada una de las capas de la 
aplicación).
